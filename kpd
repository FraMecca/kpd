#!/usr/bin/python3

import musicpd
import sys
import argparse
import shell, MPDdatabase, util, config_file
import formatter

def parse_args ():
    parser = argparse.ArgumentParser ()
    parser.add_argument ('-p', '--play', nargs = '?', default = False,
            help='toggle play, input number to play song in playlist')
    parser.add_argument ('-n', '--next', action="store_true", default=False,
            help='play next track')
    parser.add_argument ('-ps', '--previous', '--prev', action="store_true", default=False,
            help='play previous track')
    parser.add_argument ('--stop', action="store_true", default=False,
            help='stop playback')
    parser.add_argument ('--random', nargs = '?', default = False,
            help='random [on,off]')
    parser.add_argument ('-u', '--update', action="store_true", default = False,
            help='update mpd database') 
    parser.add_argument ('-a', '--add', action="store_true", default=False,
            help='add songs to playlist, useful to receive piped input from shell')
    parser.add_argument ('-s', '--search', type = str, nargs = '?', default = False,
            help='search a string in the database, casi insensitive')
    parser.add_argument ('-f', '--filter', nargs = '+', default = False,
            help='filter search result, can use \'artist\', \'album\', \'title\', grep like functionality, comma to divide various entry')
    parser.add_argument ('--clear', action = "store_true", default=False,
            help='clear playlist')
    parser.add_argument ('-pl', '--playlist', action = "store_true", default=False,
            help='show playlist')
    parser.add_argument ('--seek', nargs='?', default=False,
            help='seek current track: works by seconds or by percentage ')
    parser.add_argument ('--shuffle', action = "store_true", default=False,
            help='shuffle playlist')
    parser.add_argument ('--consume', nargs = '?', default=False,
            help='consume mode [on,off]')
    parser.add_argument ('--single', nargs = '?', default=False,
            help='single mode [on,off]')
    parser.add_argument ('--swap', nargs = 2, default=False,
            help='swap two tracks in the playlist')
    parser.add_argument ('--shell', '-sh', action='store_true', default = False,
            help='invoke shell')
    parser.add_argument ('--format', nargs= '+', default = False,
                         help='change display format, write \'kpd --format help\' for usage')

    args = parser.parse_args ()
    dictArgs = vars (args)

    return args, dictArgs
#end parse_args

def order_args (argv):
    argsDict1 = {'-h':'help', '-p':'play', '-n':'next', '-u':'update', '-s':'search', '-f':'filter', '-pl':'playlist', '-sh':'shell', '-a':'add'}
    argsDict2 = {'--help':'help', '--play':'play', '--next':'next', '--update':'update', '--search':'search', '--filter':'filter', '--playlist':'playlist', \
                 '--stop':'stop', '--random':'random', '--clear':'clear', '--seek':'seek', '--shuffle':'shuffle', '--consume':'consume', '--single':'single','--swap':'swap',\
                 '--shell':'shell', '--prev':'previous', '--previous':'previous', '--add':'add'}
    argsOrder = list ()
    for el in argv:
        if el in argsDict1:
            argsOrder.append (argsDict1[el])
        if el in argsDict2:
            argsOrder.append (argsDict2[el])
    return argsOrder


if __name__ == '__main__':

    DBlocation, host, port = config_file.parse_file ()
    argsOrder = order_args (sys.argv)
    args, dictArgs = parse_args ()
    client = util.mpdclient (DBlocation, host, port, args.filter)

    print (args.search)
## check -f -s
    if args.filter != False and not args.search: ##Check also indexes, -f non prima di -s
        print ('filter can be used only concatenated to a search')
        exit(1)

## no args
    if not len (sys.argv) > 1:
        if  client.status['state'] != 'stop':
            util.current_status (client)
        else:
            util.playlist (client, None)
        exit ()

######
    searchRes = None
    retUtil = None

    for el in argsOrder:
        if dictArgs[el] != False:
            methodToCall = getattr (util, el)
            retUtil = methodToCall (client, dictArgs[el], searchRes)

            if retUtil != None: #the only alternative is a return null in every funct
                searchRes = retUtil
        print (sys.argv)

    #pipe from shell
    if not sys.stdin.isatty() and args.add != False:
        for line in sys.stdin:
            line = line.rstrip ('\n')
            client.add (line)
#        exit ()
    #end pipe from shell

    if args.shell:
        util.shell (client, DBlocation)

    #print in a different format
    if args.format != False: ### E` BRUTTO!, dovrebbe influenzare tutti i print_status (!, evidenzia la bruttura)
        formatter.print_status (client, args.format[0])
